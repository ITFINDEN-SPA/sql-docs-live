---
title: Logical and physical showplan operator reference
description: Learn about the logical and physical operators for XML and graphical showplans.
author: rwestMSFT
ms.author: randolphwest
ms.date: 01/23/2024
ms.service: sql
ms.topic: conceptual
f1_keywords:
  - "sql13.swb.showplan.leftouterjoin.f1"
  - "sql13.swb.showplan.remotedelete.f1"
  - "sql13.swb.showplan.parallelism.f1"
  - "sql13.swb.showplan.indexspool.f1"
  - "sql13.swb.showplan.result.f1"
  - "sql13.swb.showplan.bitmapcreate.f1"
  - "sql13.swb.showplan.remotescan.f1"
  - "sql13.swb.showplan.union.f1"
  - "sql13.swb.showplan.bitmap.f1"
  - "sql13.swb.showplan.RIDLookup"
  - "sql13.swb.showplan.innerjoin.f1"
  - "sql13.swb.showplan.dynamic.f1"
  - "sql13.swb.showplan.distributestreams.f1"
  - "sql13.swb.showplan.clusteredindexdelete.f1"
  - "sql13.swb.showplan.keylookup.f1"
  - "sql13.swb.showplan.partialaggregate.f1"
  - "sql13.swb.showplan.distinctsort.f1"
  - "sql13.swb.showplan.collapse.f1"
  - "sql13.swb.showplan.print.f1"
  - "sql13.swb.showplan.crossjoin.f1"
  - "sql13.swb.showplan.convert.f1"
  - "sql13.swb.showplan.split.f1"
  - "sql13.swb.showplan.top.f1"
  - "sql13.swb.showplan.update.f1"
  - "sql13.swb.showplan.keyset.f1"
  - "sql13.swb.showplan.fetchquery.f1"
  - "sql13.swb.showplan.mergejoin.f1"
  - "sql13.swb.showplan.branchrepartition.f1"
  - "sql13.swb.showplan.tableinsert.f1"
  - "sql13.swb.showplan.clusteredindexseek.f1"
  - "sql13.swb.showplan.indexupdate.f1"
  - "sql13.swb.showplan.indexinsert.f1"
  - "sql13.swb.showplan.clusteredindexupdate.f1"
  - "sql13.swb.showplan.streamaggregate.f1"
  - "sql13.swb.showplan.columnstoreindexdelete.f1"
  - "sql13.swb.showplan.snapshot.f1"
  - "sql13.swb.showplan.remotequery.f1"
  - "sql13.swb.showplan.constantscan.f1"
  - "sql13.swb.showplan.rank.f1"
  - "sql13.swb.showplan.rightsemijoin.f1"
  - "sql13.swb.showplan.delete.f1"
  - "sql13.swb.showplan.sequence.f1"
  - "sql13.swb.showplan.locate.f1"
  - "sql13.swb.showplan.aggregate.f1"
  - "sql13.swb.showplan.rightouterjoin.f1"
  - "sql13.swb.showplan.columnstoreindexupdate.f1"
  - "sql13.swb.showplan.clusteredindexinsert.f1"
  - "sql13.swb.showplan.rowcountspool.f1"
  - "sql13.swb.showplan.columnstoreindexscan.f1"
  - "sql13.swb.showplan.leftantisemijoin.f1"
  - "sql13.swb.showplan.sort.f1"
  - "sql13.swb.showplan.leftsemijoin.f1"
  - "sql13.swb.showplan.columnstoreindexinsert.f1"
  - "sql13.swb.showplan.indexscan.f1"
  - "sql13.swb.showplan.columnstoreindexmerge.f1"
  - "sql13.swb.showplan.lazyspool.f1"
  - "sql13.swb.showplan.rightantisemijoin.f1"
  - "sql13.swb.showplan.bookmarklookup.f1"
  - "sql13.swb.showplan.remoteinsert.f1"
  - "sql13.swb.showplan.intrinsic.f1"
  - "sql13.swb.showplan.arithmeticexpression.f1"
  - "sql13.swb.showplan.populationquery.f1"
  - "sql13.swb.showplan.filter.f1"
  - "sql13.swb.showplan.if.f1"
  - "sql13.swb.showplan.hashmatchteam.f1"
  - "sql13.swb.showplan.tablevaluedfunction.f1"
  - "sql13.swb.showplan.assign.f1"
  - "sql13.swb.showplan.nestedloops.f1"
  - "sql13.swb.showplan.buildhash.f1"
  - "sql13.swb.showplan.mergeinterval.f1"
  - "sql13.swb.showplan.hashmatch.f1"
  - "sql13.swb.showplan.parametertablescan.f1"
  - "sql13.swb.showplan.tablemerge.f1"
  - "sql13.swb.showplan.switch.f1"
  - "sql13.swb.showplan.sql.f1"
  - "sql13.swb.showplan.repartitionstreams.f1"
  - "sql13.swb.showplan.logrowscan.f1"
  - "sql13.swb.showplan.assert.f1"
  - "sql13.swb.showplan.computescalar.f1"
  - "sql13.swb.showplan.broadcast.f1"
  - "sql13.swb.showplan.indexseek.f1"
  - "sql13.swb.showplan.gatherstreams.f1"
  - "sql13.swb.showplan.remoteindexscan.f1"
  - "sql13.swb.showplan.segment.f1"
  - "sql13.swb.showplan.tableupdate.f1"
  - "sql13.swb.showplan.clusteredindexscan.f1"
  - "sql13.swb.showplan.cache.f1"
  - "sql13.swb.showplan.spool.f1"
  - "sql13.swb.showplan.indexdelete.f1"
  - "sql13.swb.showplan.distinct.f1"
  - "sql13.swb.showplan.deletedscan.f1"
  - "sql13.swb.showplan.eagerspool.f1"
  - "sql13.swb.showplan.hashmatchroot.f1"
  - "sql13.swb.showplan.setfunction.f1"
  - "sql13.swb.showplan.clusteredindexmerge.f1"
  - "sql13.swb.showplan.flowdistinct.f1"
  - "sql13.swb.showplan.tabledelete.f1"
  - "sql13.swb.showplan.tablescan.f1"
  - "sql13.swb.showplan.refreshquery.f1"
  - "sql13.swb.showplan.tablespool.f1"
  - "sql13.swb.showplan.insertedscan.f1"
  - "sql13.swb.showplan.insert.f1"
  - "sql13.swb.showplan.remoteindexseek.f1"
  - "sql13.swb.showplan.fullouterjoin.f1"
  - "sql13.swb.showplan.declare.f1"
  - "sql13.swb.showplan.udx.f1"
  - "sql13.swb.showplan.while.f1"
  - "sql13.swb.showplan.remoteupdate.f1"
  - "sql13.swb.showplan.concatenation.f1"
  - "sql13.swb.showplan.computescalar"
  - "sql13.swb.showplan.foreignkeyreferencescheck"
helpviewer_keywords:
  - "execution plans [SQL Server], operators"
  - "ActualRows attribute"
  - "reading execution plan output"
  - "ActualRewinds attribute"
  - "ActualEndOfScans attribute"
  - "query tuning [SQL Server]"
  - "mapping operators [SQL Server]"
  - "operators [Database Engine query tuning]"
  - "logical operators [SQL Server], execution plans"
  - "logical operators [SQL Server], listed"
  - "physical operators [SQL Server]"
  - "ActualRebinds attribute"
  - "execution plans [SQL Server], reading output"
monikerRange: "=azuresqldb-current || >=sql-server-2016 || >=sql-server-linux-2017 || =azuresqldb-mi-current"
---
# Logical and physical showplan operator reference

[!INCLUDE [SQL Server Azure SQL Database Azure SQL Managed Instance](../includes/applies-to-version/sql-asdb-asdbmi.md)]

Operators describe how [!INCLUDE [ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement. The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement. The query plan is a tree consisting of physical operators. You can view the query plan by using the `SET SHOWPLAN` statements, the graphical execution plan options in [!INCLUDE [ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the Extended Events showplan events.

Operators are classified as logical and physical operators.

#### Logical operators

Logical operators describe the relational algebraic operation used to process a statement. In other words, logical operators describe conceptually what operation needs to be performed.

#### Physical operators

Physical operators implement the operation described by logical operators. Each physical operator is an object or routine that performs an operation. For example, some physical operators access columns or rows from a table, index or view. Other physical operators perform operations such as calculations, aggregations, data integrity checks or joins. Physical operators have costs associated with them.

The physical operators initialize, collect data, and close. Specifically, the physical operator can answer the following three method calls:

- `Open()`: The `Open()` method causes a physical operator to initialize itself and set up any required data structures. While the physical operator might receive many `Open()` calls, it usually receives only one.

- `GetRow()`: The `GetRow()` method causes a physical operator to get the first, or subsequent row of data. The physical operator might receive zero or many `GetRow()` calls.

- `Close()`: The `Close()` method causes a physical operator to perform some clean-up operations and shut itself down. A physical operator only receives one `Close()` call, but a `Close()` call isn't always guaranteed.

The `GetRow()` method returns one row of data, and the number of times it is called appears as **ActualRows** in the showplan output that is produced by the graphical and XML showplan. For more information about these `SET` options, see [SET STATISTICS PROFILE (Transact-SQL)](../t-sql/statements/set-statistics-profile-transact-sql.md) and [SET STATISTICS XML (Transact-SQL)](../t-sql/statements/set-statistics-xml-transact-sql.md).

The **ActualRebinds** and **ActualRewinds** counts that appear in showplan output refer to the number of times that the `Open()` method is called. Unless an operator is on the inner side of a nested loops join, **ActualRebinds** equals one, and **ActualRewinds** equals zero. If an operator is on the inner side of a loop join, the total number of rebinds and rewinds should equal the number of rows processed on the outer side of the join. A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated. A rewind means that none of the correlated parameters changed and the prior inner result set might be reused.

**ActualRebinds** and **ActualRewinds** are present in XML showplan output produced by using `SET STATISTICS XML ON` and the graphical showplan. They're only populated for the **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**, and **Table-valued Function** operators. **ActualRebinds** and **ActualRewinds** might also be populated for the **Assert** and **Filter** operators when the **StartupExpression** attribute is set to TRUE.

When **ActualRebinds** and **ActualRewinds** are present in an XML showplan, they're comparable to **EstimateRebinds** and **EstimateRewinds**. When they're absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**). Actual graphical showplan output displays zeros for the actual rebinds and actual rewinds when they're absent.

A related counter, **ActualEndOfScans**, is available in the XML and graphical showplan. Whenever a physical operator reaches the end of its data stream, this counter increments by one. A physical operator can reach the end of its data stream zero, one, or multiple times. As with rebinds and rewinds, the end of scans count can be more than one, only if the operator is on the inner side of a loop join. The end of scans count should be less than or equal to the sum of the number of rebinds and rewinds.

## Map physical and logical operators

The Query Optimizer creates a query plan as a tree consisting of logical operators. After the query optimizer creates the plan, the Query Optimizer chooses the most efficient physical operator for each logical operator. The query optimizer uses a cost-based approach to determine which physical operator implements a logical operator.

Usually, a logical operation can be implemented by multiple physical operators. However, in rare cases, a physical operator can implement multiple logical operations as well.

## Batch mode execution

Batch mode execution is a query processing method used to process multiple rows together (hence the term *batch*) rather than one row at a time. Batch mode processing uses algorithms that are optimized for multi-core CPUs and increased memory throughput on modern hardware. Batch mode can be used by a set of operators for both rowstore and columnstore objects. For more information, see [Query processing architecture guide](query-processing-architecture-guide.md).

## Operator descriptions

This section contains descriptions of the logical and physical operators. You can view the properties of query plans and operators using the **Properties** pane in the Query Plan view of [SQL Server Management Studio](../ssms/sql-server-management-studio-ssms.md) (SSMS) and [Azure Data Studio](/azure-data-studio/what-is-azure-data-studio).

> [!TIP]  
> Whenever a given graphical execution plan icon has a yellow circle with two right-to-left arrows, it means the operator executed in parallel. For more information about parallelism, see the [Thread and Task Architecture Guide](../relational-databases/thread-and-task-architecture-guide.md#sql-server-task-scheduling).

| Icon | Showplan operator | Description |
| --- | --- | --- |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-adaptive-join.png" border="false"::: | **Adaptive Join** | The **Adaptive Join** operator enables the choice of a hash join or nested loops join method to be deferred until after the first input has been scanned.<br /><br />**Adaptive Join** is a physical operator. For more information, see [Understanding Adaptive joins](../relational-databases/performance/joins.md#adaptive). |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-aggregate.png" border="false"::: | **Aggregate** | The **Aggregate** operator calculates an expression containing `MIN`, `MAX`, `SUM`, `COUNT`, or `AVG`.<br /><br />**Aggregate** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-arithmetic-expression.png" border="false"::: | **Arithmetic Expression** | The **Arithmetic Expression** operator computes a new value from existing values in a row. **Arithmetic Expression** isn't used in newer versions of [!INCLUDE [ssnoversion-md](../includes/ssnoversion-md.md)]. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-assert.png" border="false"::: | **Assert** | The **Assert** operator verifies a condition. For example, it validates referential integrity or ensures that a scalar subquery returns one row. For each input row, the **Assert** operator evaluates the expression in the **Properties** pane of the execution plan. If this expression evaluates to `NULL`, the row is passed through the **Assert** operator and the query execution continues. If this expression evaluates to a non-null value, the appropriate error is raised.<br /><br />**Assert** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-assign.png" border="false"::: | **Assign** | The **Assign** operator assigns the value of an expression or a constant to a variable.<br /><br />**Assign** is a language element. |
| None | **Async Concat** | The **Async Concat** operator is used only in remote queries (distributed queries). It has *n* children and one parent node. Usually, some of the children are remote computers that participate in a distributed query. **Async Concat** issues `Open()` calls to all of the children simultaneously and then applies a bitmap to each child. For each bit that is a `1`, **Async Concat** sends the output rows to the parent node on demand. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-bitmap.png" border="false"::: | **Bitmap** | [!INCLUDE [ssNoVersion](../includes/ssnoversion-md.md)] uses the **Bitmap** operator to implement bitmap filtering in parallel query plans. Bitmap filtering speeds up query execution by eliminating rows with key values that can't produce any join records before passing rows through another operator such as the **Parallelism** operator. A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree. By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves. The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.<br /><br />**Bitmap** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-bitmap.png" border="false"::: | **Bitmap Create** | The **Bitmap Create** operator appears in the showplan output where bitmaps are built.<br /><br />**Bitmap Create** is a logical operator. |
| None | **Branch Repartition** | In a parallel query plan, sometimes there are conceptual regions of iterators. All of the iterators within such a region can be executed by parallel threads. The regions themselves must be executed serially. Some of the **Parallelism** iterators within an individual region are called **Branch Repartition**. The **Parallelism** iterator at the boundary of two such regions is called **Segment Repartition**.<br /><br />**Branch Repartition** and **Segment Repartition** are logical operators. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-broadcast.png" border="false"::: | **Broadcast** | **Broadcast** has one child node and *n* parent nodes. **Broadcast** sends its input rows to multiple consumers on demand. Each consumer gets all of the rows. For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables are built. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-batch-hash-table-build.png" border="false"::: | **Build Hash** | Indicates the build of a batch hash table for a memory optimized columnstore index.<br /><br />**Applies to:** [!INCLUDE [sssql11-md](../includes/sssql11-md.md)] only. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-clustered-index-delete.png" border="false"::: | **Clustered Index Delete** | The **Clustered Index Delete** operator deletes rows from the clustered index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. If a *SeekPredicate* or *Predicate* is present, then only those rows that satisfy the predicate are deleted.<br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Clustered Index Delete** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-clustered-index-insert.png" border="false"::: | **Clustered Index Insert** | The **Clustered Index Insert** operator inserts rows from its input into the clustered index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. The XML showplan includes **SetPredicate** and **ColumnReference** properties, which can be used to determine the value to which each column is set. If **Clustered Index Insert** has no children for insert values, the row inserted is taken from the **Insert** operator itself.<br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Clustered Index Insert** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-clustered-index-merge.png" border="false"::: | **Clustered Index Merge** | The **Clustered Index Merge** operator applies a merge data stream to a clustered index. The operator deletes, updates, or inserts rows from the clustered index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. The actual operation performed depends on the runtime value of the **ActionColumn** property.<br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Clustered Index Merge** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-clustered-index-scan.png" border="false"::: | **Clustered Index Scan** | The **Clustered Index Scan** operator scans the clustered index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. When an optional **Predicate** is present, only those rows that satisfy the predicate are returned. If the **Ordered** property in the **Properties** pane or XML showplan is **True**, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them. If the **Ordered** property is **False**, the [!INCLUDE [ssde-md](../includes/ssde-md.md)] scans the index in the optimal way, without necessarily sorting the output.<br /><br />**Clustered Index Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-clustered-index-seek.png" border="false"::: | **Clustered Index Seek** | The **Clustered Index Seek** operator uses the seeking ability of indexes to retrieve rows from a clustered index. The **Object** property, listed in the **Properties** pane of the graphical and XML showplans, contains the name of the clustered index being used. The **SeekPredicate** contains the predicate for the seek. The [!INCLUDE [ssde-md](../includes/ssde-md.md)] uses the index to process only those rows that satisfy the **SeekPredicate**. It can also include a **Predicate** property where the [!INCLUDE [ssde-md](../includes/ssde-md.md)] evaluates against all rows that satisfy the **SeekPredicate**, but this is optional and doesn't use indexes to complete this process.<br /><br />If the **Ordered** property in the **Properties** pane or XML showplan is **True**, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them. If the **Ordered** property is **False**, the [!INCLUDE [ssde-md](../includes/ssde-md.md)] searches the index in the optimal way, without necessarily sorting the output. Requiring the output to retain its ordering can be less efficient than producing nonsorted output.<br /><br />**Clustered Index Seek** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-clustered-index-update.png" border="false"::: | **Clustered Index Update** | The **Clustered Index Update** operator updates input rows in the clustered index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. If the **Predicate** property is present, only those rows that satisfy this predicate are updated. If the **SetPredicate** property is present, each updated column is set to this value. If the **DefineValue** property is present, the values that this operator defines are listed. These values might be referenced in the `SET` clause or elsewhere within this operator and elsewhere within this query.<br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Clustered Index Update** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-collapse.png" border="false"::: | **Collapse** | The **Collapse** operator optimizes update processing. When an update is performed, it can be split (using the **Split** operator) into a delete and an insert. The **Properties** pane contains a *group by* predicate that specifies a list of key columns. If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single, more efficient update operation.<br /><br />**Collapse** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-columnstore-index-delete.png" border="false"::: | **Columnstore Index Delete** | The **Columnstore Index Delete** operator represents the deletion of rows from the columnstore index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. Deletion occurs via the **Clustered Index Delete** for a clustered columnstore index, and via the **Index Delete** operator for a nonclustered columnstore index. The index type (*Clustered*, *NonClustered*, or *ViewNonClustered*) is specified in the **IndexKind** property in the XML showplan. The *SeekPredicate* is not supported for a **Columnstore Index Delete**. Rows to be deleted are read from a child operator.<br /><br />**Columnstore Index Delete** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-columnstore-index-insert.png" border="false"::: | **Columnstore Index Insert** | The **Columnstore Index Insert** operator represents the insertion of rows from its input into the columnstore index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans.  Insertion occurs via the **Clustered Index Insert** for a clustered columnstore index, and via the **Index Insert** operator for a nonclustered columnstore index. The index type (*Clustered*, *NonClustered*, or *ViewNonClustered*) is specified in the **IndexKind** property in the XML showplan. The XML showplan includes **SetPredicate** and **ColumnReference** properties, which can be used to determine the value to which each column is set. <br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Columnstore Index Insert** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-columnstore-index-merge.png" border="false"::: | **Columnstore Index Merge** | The **Columnstore Index Merge** represents the application of a merge data stream using the **Clustered Index Merge** operator. The operator deletes, updates, or inserts rows from the clustered columnstore index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. The actual operation performed depends on the runtime value of the **ActionColumn** property.<br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Columnstore Index Merge** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-columnstore-index-scan.png" border="false"::: | **Columnstore Index Scan** | The **Columnstore Index Scan** operator represents a scan of the columnstore index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. The scan occurs via the **Clustered Index Scan** for a clustered columnstore index, and via the **Index Scan** operator for a nonclustered columnstore index. The index type (*Clustered*,  *NonClustered*, or *ViewNonClustered*) is specified in the **IndexKind** property in the XML showplan. When an optional **Predicate** is present, only those rows that satisfy the predicate are returned. The **SeekPredicate** property is only available for a partitioned columnstore index, and only equality or inequality conditions.  If the partitioned column is in query predicate, partition elimination can reduce the number of rowgroups to scan.<br /><br />**Columnstore Index Scan** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-columnstore-index-update.png" border="false"::: | **Columnstore Index Update** | The **Columnstore Index Update** operator represents an update to one or more rows in the columnstore index specified in the **Object** property, listed in the **Properties** pane of the graphical and XML showplans. Updates occur via the **Clustered Index Update** operator for a clustered columnstore index, and via the **Index Update** operator for a nonclustered columnstore index. The index type (*Clustered*,  *NonClustered*, or *ViewNonClustered*) is specified in the **IndexKind** property in the XML showplan.  The *SeekPredicate* is not supported for a **Columnstore Index Update**.  Rows to be updated are read from a child operator. If the **SetPredicate** property is present, each updated column is set to this value. If the **DefineValue** property is present, the values that this operator defines are listed. These values might be referenced in the `SET` clause or elsewhere within this operator and elsewhere within this query.<br /><br />**Note:** Changes to clustered indexes might affect nonclustered indexes.<br /><br />**Columnstore Index Update** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-compute-scalar.png" border="false"::: | **Compute Scalar** | The **Compute Scalar** operator evaluates an expression to produce a computed scalar value. This might then be returned to the user, referenced elsewhere in the query, or both. An example of both is in a filter predicate or join predicate.<br /><br />**Compute Scalar** operators that appear in showplans generated by `SET STATISTICS XML` might not contain the **RunTimeInformation** element. In graphical showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE [ssManStudioFull](../includes/ssmanstudiofull-md.md)]. When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the runtime query plan. The number of executions in showplan output generated by `SET STATISTICS PROFILE` is equivalent to the sum of rebinds and rewinds in showplans generated by `SET STATISTICS XML`.<br /><br />**Compute Scalar** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-concatenation.png" border="false"::: | **Concatenation** | The **Concatenation** operator scans multiple inputs, returning each row scanned. **Concatenation** is typically used to implement the [!INCLUDE [tsql](../includes/tsql-md.md)] `UNION ALL` construct. The **Concatenation** physical operator has two or more inputs and one output. Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.<br /><br />**Concatenation** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-conditional.png" border="false"::: | **Conditional** (**If** and **While**) | The **Conditional** operator carries out conditional processing based on an `IF` or `WHILE` loop. **If** and **While** are language elements. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-constant-scan.png" border="false"::: | **Constant Scan** | The **Constant Scan** operator introduces one or more constant rows into a query. A **Compute Scalar** operator is often used after a **Constant Scan** to add columns to a row produced by the **Constant Scan** operator. **Constant Scan** can generate one or more rows with zero or more columns. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-convert.png" border="false"::: | **Convert** | The **Convert** operator converts one scalar data type to another.<br /><br />**Convert** is a language element. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-join.png" border="false"::: | **Cross Join** | The **Cross Join** operator joins each row from the first (top) input with each row from the second (bottom) input.<br /><br />**Cross Join** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-cursor-catch-all.png" border="false"::: | **Cursor** | The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed. The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor. Each step in the execution of a cursor involves a physical operator. The logical operators describe a property of the cursor, such as the cursor is read only.<br /><br />Logical operators include **Asynchronous**, **Optimistic**, **Primary**, **Read Only**, **Scroll Locks**, **Secondary**, and **Synchronous**.<br /><br />Physical operators include **Dynamic**, **Fetch Query**, **Keyset**, **Population Query**, **Refresh Query**, and **Snapshot**. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-declare.png" border="false"::: | **Declare** | The **Declare** operator allocates a local variable in the query plan.<br /><br />**Declare** is a language element. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-delete.png" border="false"::: | **Delete** | The **Delete** operator deletes rows (from an object) that satisfy the optional predicate in the **Properties** pane. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-deleted-scan.png" border="false"::: | **Deleted Scan** | In triggers, the **Deleted Scan** operator scans the **deleted** table. |
| None | **Distinct** | The **Distinct** operator removes duplicates from a rowset or from a collection of values.<br /><br />**Distinct** is a logical operator. |
| None | **Distinct Sort** | The **Distinct Sort** logical operator scans the input, removing duplicates and sorting by the columns specified in the *distinct order by* predicate of the **Properties** pane.<br /><br />**Distinct Sort** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-parallelism-distribute-streams.png" border="false"::: | **Distribute Streams** | The **Distribute Streams** operator is used only in parallel query plans. The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams. The record contents and format aren't changed. Each record from the input stream appears in one of the output streams. This operator automatically preserves the relative order of the input records in the output streams. Usually, hashing is used to decide to which output stream a particular input record belongs.<br /><br />If the output is partitioned, then the **Properties** pane contains a *partition columns* predicate and the partitioning columns.<br /><br />**Distribute Streams** is a logical operator |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-dynamic.png" border="false"::: | **Dynamic** | The **Dynamic** operator uses a cursor that can see all changes made by others. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-spool.png" border="false"::: | **Eager Spool** | The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the [tempdb database](databases/tempdb-database.md). If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input. If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input. The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.<br /><br />**Eager Spool** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-fetch-query.png" border="false"::: | **Fetch Query** | The **Fetch Query** operator retrieves rows when a fetch is issued against a cursor. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-filter.png" border="false"::: | **Filter** | The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the **Properties** pane. |
| None | **Flow Distinct** | The **Flow Distinct** operator scans the input, removing duplicates. Whereas the **Distinct** operator consumes all input before producing any output, the **Flow Distinct** operator returns each row as it's obtained from the input (unless that row is a duplicate, in which case it's discarded).<br /><br />**Flow Distinct** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-referential-integrity.png" border="false"::: | **Foreign Key References Check** | The **Foreign Key References Check** operator performs referential integrity checks in place, by comparing the modified row to the rows in the referencing tables to verify that the modification doesn't break the referential integrity. The **Foreign Key References Check** operator is used when more than 253 foreign key references exist on the same primary or unique key.<br /><br />**Foreign Key References Check** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-join.png" border="false"::: | **Full Outer Join** | The **Full Outer Join** logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input. It also returns rows from:<br /><br />- The first input that had no matches in the second input.<br /><br />- The second input that had no matches in the first input.<br /><br />The input that doesn't contain the matching values is returned as a null value.<br /><br />**Full Outer Join** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-parallelism.png" border="false"::: | **Gather Streams** | The **Gather Streams** operator is only used in parallel query plans. The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams. The record contents and format aren't changed. If this operator is order preserving, all input streams must be ordered. If the output is ordered, the **Properties** pane contains an *order by* predicate and the names of columns being ordered.<br /><br />**Gather Streams** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-hash-match.png" border="false"::: | **Hash Match** | The **Hash Match** operator builds a hash table by computing a hash value for each row from its build input. A *hash* predicate, with a list of columns used to create a hash value, appears in the **Properties** pane. Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches. If a residual predicate is present (identified by `RESIDUAL:()` in the **Properties** pane), that predicate must also be satisfied for rows to be considered a match. Behavior depends on the logical operation being performed:<br /><br />- For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table. Output matches (or nonmatches) as dictated by the join type. If multiple joins use the same join column, these operations are grouped into a hash team.<br /><br />- For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions). When the hash table is built, scan the table and output all entries.<br /><br />- For the union operator, use the first input to build the hash table (removing duplicates). Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.<br /><br />**Hash Match** is a physical operator. For more information, see [Understanding Hash joins](../relational-databases/performance/joins.md#hash). |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nonclustered-index-delete.png" border="false"::: | **Index Delete** | The **Index Delete** operator deletes rows from the nonclustered index specified in the **Properties** pane.<br /><br />**Index Delete** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nonclustered-index-insert.png" border="false"::: | **Index Insert** | The **Index Insert** operator inserts rows from its input into the nonclustered index specified in the **Properties** pane. The **Properties** pane also contains a *set* predicate, which indicates the value to which each column is set.<br /><br />**Index Insert** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nonclustered-index-scan.png" border="false"::: | **Index Scan** | The **Index Scan** operator retrieves all rows from the nonclustered index specified in the **Properties** pane. If an optional *where* predicate appears in the **Properties** pane, only those rows that satisfy the predicate are returned.<br /><br />**Index Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nonclustered-index-seek.png" border="false"::: | **Index Seek** | The **Index Seek** operator uses the seeking ability of indexes to retrieve rows from a nonclustered index. The **Properties** pane contains the name of the nonclustered index being used. It also contains the *seek* predicate. The [!INCLUDE [ssde-md](../includes/ssde-md.md)] uses the index to process only those rows that satisfy the *seek* predicate. It optionally might include a *where* predicate, which the [!INCLUDE [ssde-md](../includes/ssde-md.md)] evaluates against all rows that satisfy the *seek* predicate (it doesn't use the indexes to do this). If the **Properties** pane contains the `ORDERED` clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them. If the `ORDERED` clause isn't present, the [!INCLUDE [ssde-md](../includes/ssde-md.md)] searches the index in the optimal way (which doesn't guarantee that the output is sorted). Allowing the output to retain its ordering might be less efficient than producing nonsorted output.<br /><br />**Index Seek** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nonclustered-index-spool.png" border="false"::: | **Index Spool** | The **Index Spool** operator contains a *seek* predicate in the **Properties** pane. The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the [tempdb database](databases/tempdb-database.md) and existing only for the lifetime of the query), and builds a nonclustered index on the rows. This allows you to use the seeking capability of indexes to output only those rows that satisfy the *seek* predicate. If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.<br /><br />**Index Spool** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nonclustered-index-update.png" border="false"::: | **Index Update** | The **Index Update** physical operator updates rows from its input in the nonclustered index specified in the **Properties** pane. If a *set* predicate is present, each updated column is set to this value.<br /><br />**Index Update** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-join.png" border="false"::: | **Inner Join** | The **Inner Join** operator returns each row that satisfies the join predicate of the first (top) input with the second (bottom) input.<br /><br />**Inner Join** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-insert.png" border="false"::: | **Insert** | The **Insert** operator inserts each row from its input into the object specified in the **Properties** pane. The physical operator is either the **Table Insert**, **Index Insert**, or **Clustered Index Insert** operator.<br /><br />**Insert** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-inserted-scan.png" border="false"::: | **Inserted Scan** | In triggers, the **Inserted Scan** operator scans the **inserted** table.<br /><br />**Inserted Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-intrinsic.png" border="false"::: | **Intrinsic** | The **Intrinsic** operator invokes an internal [!INCLUDE [tsql](../includes/tsql-md.md)] function.<br /><br />**Intrinsic** is a language element. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-iterator-catch-all.png" border="false"::: | **Iterator** | The **Iterator** catchall icon is displayed when a suitable icon for the iterator can't be found by the logic that produces graphical showplans. The catchall icon doesn't necessarily indicate an error condition. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-key-lookup.png" border="false"::: | **Key Lookup** | The **Key Lookup** operator is a bookmark lookup on a table with a clustered index. The **Properties** pane contains the name of the clustered index and the clustering key used to look up the row in the clustered index. **Key Lookup** is always accompanied by a **Nested Loops** operator. If the `WITH PREFETCH` clause appears in the **Properties** pane, the query processor has determined that it's optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.<br /><br />The use of a **Key Lookup** operator in a query plan indicates that the query might benefit from performance tuning. For example, query performance might be improved by adding a covering index. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-keyset.png" border="false"::: | **Keyset** | The **Keyset** operator uses a cursor that can see updates, but not inserts, made by others. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-language-construct-catch-all.png" border="false"::: | **Language Element** | The **Language Element** catchall icon is displayed when a suitable icon for the iterator can't be found by the logic that produces graphical showplans. The catchall icon doesn't necessarily indicate an error condition. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-spool.png" border="false"::: | **Lazy Spool** | The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the [tempdb database](databases/tempdb-database.md). If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input. If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input. The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.<br /><br />**Lazy Spool** is a logical operator. |
| None | **Left Anti Semi Join** | The **Left Anti Semi Join** operator returns each row from the first (top) input when there's no matching row in the second (bottom) input. If no join predicate exists in the **Properties** pane, each row is a matching row.<br /><br />**Left Anti Semi Join** is a logical operator. |
| None | **Left Outer Join** | The **Left Outer Join** operator returns each row that satisfies the join predicate of the first (top) input with the second (bottom) input. It also returns any rows from the first input that have no matching rows in the second input. The nonmatching rows in the second input are returned as null values. If no join predicate exists in the **Properties** pane, each row is a matching row.<br /><br />**Left Outer Join** is a logical operator. |
| None | **Left Semi Join** | The **Left Semi Join** operator returns each row from the first (top) input when there's a matching row in the second (bottom) input. If no join predicate exists in the **Properties** pane, each row is a matching row.<br /><br />**Left Semi Join** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-log-row-scan.png" border="false"::: | **Log Row Scan** | The **Log Row Scan** operator scans the transaction log.<br /><br />**Log Row Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-merge-interval.png" border="false"::: | **Merge Interval** | The **Merge Interval** operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries. This operator typically appears before one or more **Compute Scalar** operators over **Constant Scan** operators, which construct the intervals (represented as columns in a row) that this operator merges.<br /><br />**Merge Interval** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-merge-join.png" border="false"::: | **Merge Join** | The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.<br /><br />In the **Properties** pane, the **Merge Join** operator contains a *merge* predicate if the operation is performing a one-to-many join, or a *many-to-many merge* predicate if the operation is performing a many-to-many join. The **Properties** pane also includes a comma-separated list of columns used to perform the operation. The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan. Merge join is particularly effective if explicit sorting isn't required, for example, if there's a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with rollup.<br /><br />**Merge Join** is a physical operator. For more information, see [Understanding Merge joins](../relational-databases/performance/joins.md#merge). |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-nested-loops.png" border="false"::: | **Nested Loops** | The **Nested Loops** operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.<br /><br />Nested loop joins perform a search on the inner table for each row of the outer table, typically using an index. The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input. Any rows that satisfy the (optional) predicate in the **Properties** pane are returned as applicable, based on the logical operation being performed. When the `OPTIMIZED` attribute is set to `True`, it means that an Optimized Nested Loops (or Batch Sort) is used.<br /><br />**Nested Loops** is a physical operator. For more information, see [Understanding Nested Loops joins](../relational-databases/performance/joins.md#nested_loops). |
| None | **Online Index Insert** | The **Online Index Insert** operator indicates that an index operation (create, alter, or drop) is performed online. That is, the underlying table data remains available to users during the index operation.<br /><br />**Online Index Insert** is a physical operator. |
| <a id="exchange"></a> None | **Parallelism** | The **Parallelism** operator (or Exchange Iterator) performs the distribute streams, gather streams, and repartition streams logical operations. The **Properties** pane can contain a *partition columns* predicate with a comma-separated list of the columns being partitioned. The **Properties** pane can also contain an *order by* predicate, listing the columns to preserve the sort order for during partitioning.<br /><br />**Note:** If a query has been compiled as a parallel query, but at run time it's run as a serial query, the showplan output generated by `SET STATISTICS XML` or by using the **Include Actual Execution Plan** option in [!INCLUDE [ssManStudioFull](../includes/ssmanstudiofull-md.md)] doesn't contain the `RunTimeInformation` element for the **Parallelism** operator. In `SET STATISTICS PROFILE` output, the actual row counts and actual number of executions display zeroes for the **Parallelism** operator. When either condition occurs, it means that the **Parallelism** operator was only used during query compilation and not in the runtime query plan. Sometimes parallel query plans are run in serial if there's a high concurrent load on the server.<br /><br />**Parallelism** is a physical operator. For more information about the Parallelism operator, see [The Parallelism Operator](/archive/blogs/craigfr/the-parallelism-operator-aka-exchange). |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-parameter-table-scan.png" border="false"::: | **Parameter Table Scan** | The **Parameter Table Scan** operator scans a table that is acting as a parameter in the current query. Typically, this is used for `INSERT` queries within a stored procedure.<br /><br />**Parameter Table Scan** is a logical and physical operator. |
| None | **Partial Aggregate** | **Partial Aggregate** is used in parallel plans. It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") isn't necessary. **Hash Match** is the only physical operator (iterator) that implements partial aggregation.<br /><br />**Partial Aggregate** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-population-query.png" border="false"::: | **Population Query** | The **Population Query** operator populates the work table of a cursor when the cursor is opened. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-refresh-query.png" border="false"::: | **Refresh Query** | The **Refresh Query** operator fetches current data for rows in the fetch buffer. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-delete.png" border="false"::: | **Remote Delete** | The **Remote Delete** operator deletes the input rows from a remote object.<br /><br />**Remote Delete** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-index-scan.png" border="false"::: | **Remote Index Scan** | The **Remote Index Scan** operator scans the remote index specified in the **Properties** pane.<br /><br />**Remote Index Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-index-seek.png" border="false"::: | **Remote Index Seek** | The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows. The **Properties** pane contains the name of the remote index being used and the *seek* predicate.<br /><br />**Remote Index Seek** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-insert.png" border="false"::: | **Remote Insert** | The **Remote Insert** operator inserts the input rows into a remote object.<br /><br />**Remote Insert** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-query.png" border="false"::: | **Remote Query** | The **Remote Query** operator submits a query to a remote source. The text of the query sent to the remote server appears in the **Properties** pane.<br /><br />**Remote Query** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-scan.png" border="false"::: | **Remote Scan** | The **Remote Scan** operator scans a remote object. The name of the remote object appears in the **Properties** pane.<br /><br />**Remote Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-update.png" border="false"::: | **Remote Update** | The **Remote Update** operator updates the input rows in a remote object.<br /><br />**Remote Update** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-parallelism-repartition-streams.png" border="false"::: | **Repartition Streams** | The **Repartition Streams** operator (or exchange iterator) consumes multiple streams and produces multiple streams of records. The record contents and format aren't changed. If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced. Each record from an input stream is placed into one output stream. If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams. If the output is partitioned, the **Properties** pane contains a *partition columns* predicate and the partitioning columns. If the output is ordered, the **Properties** pane contains an *order by* predicate and the columns being ordered. The operator is used only in parallel query plans.<br /><br />**Repartition Streams** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-result.png" border="false"::: | **Result** | The **Result** operator is the data returned at the end of a query plan. This is usually the root element of a showplan.<br /><br />**Result** is a language element. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-row-id-nonclustered-locate.png" border="false"::: | **RID Lookup** | **RID Lookup** is a bookmark lookup on a heap using a supplied row identifier (RID). The **Properties** pane contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up. **RID Lookup** is always accompanied by a `NESTED LOOP JOIN`.<br /><br />**RID Lookup** is a physical operator. For more information about bookmark lookups, see [Read Committed and Bookmark Lookup](/archive/blogs/craigfr/read-committed-and-bookmark-lookup). |
| None | **Right Anti Semi Join** | The **Right Anti Semi Join** operator outputs each row from the second (bottom) input when a matching row in the first (top) input doesn't exist. A matching row is defined as a row that satisfies the predicate in the **Properties** pane (if no predicate exists, each row is a matching row).<br /><br />**Right Anti Semi Join** is a logical operator. |
| None | **Right Outer Join** | The **Right Outer Join** operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input. It also returns any rows from the second input that had no matching rows in the first input, joined with `NULL`. If no join predicate exists in the **Properties** pane, each row is a matching row.<br /><br />**Right Outer Join** is a logical operator. |
| None | **Right Semi Join** | The **Right Semi Join** operator returns each row from the second (bottom) input when there's a matching row in the first (top) input. If no join predicate exists in the **Properties** pane, each row is a matching row.<br /><br />**Right Semi Join** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-remote-count-spool.png" border="false"::: | **Row Count Spool** | The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them. This operator is used when it's important to check for the existence of rows, rather than the data contained in the rows. For example, if a **Nested Loops** operator performs a left semi join operation and the join predicate applies to inner input, a row count spool might be placed at the top of the inner input of the **Nested Loops** operator. Then the **Nested Loops** operator can determine how many rows are output by the row count spool (because the actual data from the inner side isn't needed) to determine whether to return the outer row.<br /><br />**Row Count Spool** is a physical operator. |
| None | **Segment Repartition** | In a parallel query plan, sometimes there are conceptual regions of iterators. All of the iterators within such a region can be executed by parallel threads. The regions themselves must be executed serially. Some of the **Parallelism** iterators within an individual region are called **Branch Repartition**. The **Parallelism** iterator at the boundary of two such regions is called **Segment Repartition**.<br /><br />**Branch Repartition** and **Segment Repartition** are logical operators. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-segment.png" border="false"::: | **Segment** | The **Segment** operator divides the input set into segments based on the value of one or more columns. These columns are shown as arguments in the **Segment** operator. The operator then outputs one segment at a time.<br /><br />**Segment** is a physical and logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-sequence-project.png" border="false"::: | **Sequence Project** | The **Sequence Project** operator adds columns to perform computations over an ordered set. It divides the input set into segments based on the value of one or more columns. The operator then outputs one segment at a time. These columns are shown as arguments in the **Sequence Project** operator.<br /><br />**Sequence Project** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-sequence.png" border="false"::: | **Sequence** | The **Sequence** operator drives wide update plans. Functionally, it executes each input in sequence (top to bottom). Each input is usually an update of a different object. It returns only those rows that come from its last (bottom) input.<br /><br />**Sequence** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-snapshot.png" border="false"::: | **Snapshot** | The **Snapshot** operator creates a cursor that doesn't see changes made by others. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-sort.png" border="false"::: | **Sort** | The **Sort** operator sorts all incoming rows. The **Properties** pane contains either a *distinct order by* predicate if duplicates are removed by this operation, or an *order by* predicate with a comma-separated list of the columns being sorted. The columns are prefixed with the value `ASC` if the columns are sorted in ascending order, or the value `DESC` if the columns are sorted in descending order.<br /><br />**Sort** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-split.png" border="false"::: | **Split** | The **Split** operator is used to optimize update processing. It splits each update operation into a delete and an insert operation.<br /><br />**Split** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-spool.png" border="false"::: | **Spool** | The **Spool** operator saves an intermediate query result to the [tempdb database](databases/tempdb-database.md). |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-stream-aggregate.png" border="false"::: | **Stream Aggregate** | The **Stream Aggregate** operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query. The output of this operator can be referenced by later operators in the query, returned to the client, or both. The **Stream Aggregate** operator requires input ordered by the columns within its groups. The optimizer uses a **Sort** operator before this operator if the data isn't already sorted due to a previous **Sort** operator, or due to an ordered index seek or scan. In the `SHOWPLAN_ALL` statement or the graphical execution plan in [!INCLUDE [ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the *group by* predicate are listed in the **Properties** pane, and the aggregate expressions are listed in the **Defined Values** column.<br /><br />**Stream Aggregate** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-switch.png" border="false"::: | **Switch** | **Switch** is a special type of concatenation iterator that has *n* inputs. An expression is associated with each **Switch** operator. Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream. One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.<br /><br />**Switch** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-delete.png" border="false"::: | **Table Delete** | The **Table Delete** operator deletes rows from the table specified in the **Properties** pane of the query execution plan.<br /><br />**Table Delete** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-insert.png" border="false"::: | **Table Insert** | The **Table Insert** operator inserts rows from its input into the table specified in the **Properties** pane of the query execution plan. The **Properties** pane also contains a *set* predicate, which indicates the value to which each column is set. If **Table Insert** has no children for insert values, then the row inserted is taken from the Insert operator itself.<br /><br />**Table Insert** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-merge.png" border="false"::: | **Table Merge** | The **Table Merge** operator applies a merge data stream to a heap. The operator deletes, updates, or inserts rows in the table specified in the **Properties** pane of the operator. The actual operation performed depends on the runtime value of the **ActionColumn** property<br /><br />**Table Merge** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-scan.png" border="false"::: | **Table Scan** | The **Table Scan** operator retrieves all rows from the table specified in the **Properties** pane of the query execution plan. If a *where* predicate appears in the **Properties** pane, only those rows that satisfy the predicate are returned.<br /><br />**Table Scan** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-spool.png" border="false"::: | **Table Spool** | The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb database](databases/tempdb-database.md) and existing only for the lifetime of the query. If the operator is rewound (for example, by a **Nested Loops** operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.<br /><br />**Table Spool** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-update.png" border="false"::: | **Table Update** | The **Table Update** operator updates input rows in the table specified in the **Properties** pane of the query execution plan. The *set* predicate determines the value of each updated column. These values might be referenced in the `SET` clause or elsewhere within this operator, and elsewhere within this query.<br /><br />**Table Update** is a physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-valued-function.png" border="false"::: | **Table-valued Function** | The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE [tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb database](databases/tempdb-database.md). When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.<br /><br />Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator. **Table-valued Function** can be evaluated with different parameter values:<br /><br />- **Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order. Other input parameters might restrict XML nodes returned to a subset of XML document.<br /><br />- **Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.<br /><br />**Table-valued Function** is a logical and physical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-top.png" border="false"::: | **Top** | The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order. The **Properties** pane can contain a list of the columns that are being checked for ties. In update plans, the **Top** operator is used to enforce row count limits.<br /><br />**Top** is a logical and physical operator. |
| None | **Top N Sort** | **Top N Sort** is similar to the **Sort** iterator, except that only the first *N* rows are needed, and not the entire result set. For small values of *N*, the [!INCLUDE [ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory. For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* isn't a parameter. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-udx-extended-operator.png" border="false"::: | **UDX** | Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE [ssNoVersion](../includes/ssnoversion-md.md)].<br /><br />- Extended operator (UDX) **FOR XML** is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row. It's an order sensitive XML aggregation operator.<br /><br />- Extended operator (UDX) **XML SERIALIZER** is an order sensitive XML aggregation operator. It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.<br /><br />- Extended operator (UDX) **XML FRAGMENT SERIALIZER** is a special type of **XML SERIALIZER** that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.<br /><br />- Extended operator (UDX) **XQUERY STRING** evaluates the XQuery string value of input rows representing XML nodes. It's an order sensitive string aggregation operator. It outputs one row with columns representing the XQuery scalar that contains string value of the input.<br /><br />- Extended operator (UDX) **XQUERY LIST DECOMPOSER** is an XQuery list decomposition operator. For each input row representing an XML node, it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.<br /><br />- Extended operator (UDX) **XQUERY DATA** evaluates the XQuery `fn:data()` function on input representing XML nodes. It's an order sensitive string aggregation operator. It outputs one row with columns representing XQuery scalar that contains the result of `fn:data()`.<br /><br />- Extended operator **XQUERY CONTAINS** evaluates the XQuery `fn:contains()` function on input representing XML nodes. It's an order sensitive string aggregation operator. It outputs one row with columns representing XQuery scalar that contains the result of `fn:contains()`.<br /><br />- Extended operator **UPDATE XML NODE** updates XML node in the XQuery replace data modification extension in the `modify()` method on XML type.<br /><br />**UDX** operators are both logical and physical operators. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-union.png" border="false"::: | **Union** | The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.<br /><br />**Union** is a logical operator. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-update.png" border="false"::: | **Update** | The **Update** operator updates each row from its input in the object specified in the **Properties** pane of the query execution plan.<br /><br />**Update** is a logical operator. The physical operator is **Table Update**, **Index Update**, or **Clustered Index Update**. |
| :::image type="icon" source="media/showplan-logical-and-physical-operators-reference/icon-table-spool.png" border="false"::: | **Window Spool** | The **Window Spool** operator expands each row into the set of rows that represents the window associated with it. In a query, the `OVER` clause defines the window within a query result set and a window function then computes a value for each row in the window.<br /><br />**Window Spool** is a logical and physical operator. |

[!INCLUDE [sql-b-tree](../includes/sql-b-tree.md)]
